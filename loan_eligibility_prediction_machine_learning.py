# -*- coding: utf-8 -*-
"""Loan Eligibility Prediction - Machine Learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S011K-kcGZgOdui0dd3kjIiTO--ep9A3

**Introduction**

In this notebook kernal, I'm going to predictions customers are eligible for the loan and check whether what are the missing criteria to know why customer not getting loan to make there own house.
We will learning about, Data Analysis Preprocess such as,

Steps are:

Gathering Data

Exploratory Data Analysis

Data Visualizations

Machine Learning Model Decision.

Traing the ML Model

Predict Model

Deploy Model

The Problem is,

In a Simple Term, Company wants to make automate the Loan Eligibility Process in a real time scenario related to customer's detail provided while applying application for home loan forms.
You will use the training set to build your model, and the test set to validate it. Both the files are stored on the web as CSV files; their URLs are already available as character strings in the sample code.

First of all, we need to importing the necessary packages to work with the data to solve our problem

**Import Packages**
"""

import numpy as np
import pandas as pd

import os

for dirname, _, filenames in os.walk('/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

"""You can load this data with the read_csv() method from pandas package. It converts the data set to a python dataframe

Dataset Key Information.

Loan_ID--------------> Unique Loan ID.

Gender --------------> Male/ Female

Married --------------> Applicant married (Y/N)

Dependents ------------> Number of dependents

Education -------------> Applicant Education (Graduate/ Under Graduate)

Self_Employed ---------> Self-employed (Y/N)

ApplicantIncome -------> Applicant income

CoapplicantIncome -----> Coapplicant income

LoanAmount -----------> Loan amount in thousands

Loan_Amount_Term ------> Term of a loan in months

Credit_History --------> Credit history meets guidelines

Property_Area ---------> Urban/ Semi-Urban/ Rural

Loan_Status -----------> Loan approved (Y/N)


1. Gathering Data
"""

loan_train = pd.read_csv('/content/loan-train (2).csv')
loan_test = pd.read_csv('/content/loan-test (3).csv')

"""Lets display the some few information from our large datasets
Here, We shows the first five rows from dataset
"""

loan_train.head()

"""As we can see in the above output, there are too many columns, ( columns known as features as well. )
We can also use loan_train to show few rows from the first five and last five record from the dataset
"""

loan_train

"""Here, we can see there are many rows and many columns, To know how many records and columns are available in our dataset, we can use the shape attribute or we can use len() to know how many records and how many features available in the dataset."""

print("Rows: ", len(loan_train))

"""Pandas has inbuild attribute to get all column from the dataset, With the help of this feature we can get the how many column available we have"""

print("Columns: ", len(loan_train.columns))

"""Also we can get the shape of the dataset using shape attribute"""

print("Shape : ", loan_train.shape)

"""After we collecting the data, Next step we need to understand what kind of data we have.

Also we can get the column as an list(array) from dataset

Note: DataFrame.columns returns the total columns of the dataset, Store the number of columns in variable loan_train_columns
"""

loan_train_columns = loan_train.columns
loan_train_columns

"""Now, Understanding the Data

First of all we use the loan_train.describe() method to shows the important information from the dataset

It provides the count, mean, standard deviation (std), min, quartiles and max in its output.
"""

loan_train.describe()

"""As I said the above cell, this the information of all the methamatical details from dataset. Like count, mean, standard deviation (std), min, quartiles(25%, 50%, 75%) and max.


Another method is info(), This method show us the information about the dataset, Like

What's the type of culumn have?
How many rows available in the dataset?
What are the features are there?
How many null values available in the dataset?
Ans so on.
"""

loan_train.info()

"""As we can see in the output.

There are 614 entries

There are total 13 features (0 to 12)

There are three types of datatype dtypes: float64(4), int64(1), object(8)

It's Memory usage that is, memory usage: 62.5+ KB

Also, We can check how many missing values available in the Non-Null Count column


2. Exploratory Data Analysis

In this section, We learn about extra information about data and it's characteristics.

First of all, We explore object type of data So let's make a function to know how many types of values available in the column
"""

def explore_object_type(df ,feature_name):
    """
    To know, How many values available in object('categorical') type of features
    And Return Categorical values with Count.
    """
    if df[feature_name].dtype ==  'object':
        print(df[feature_name].value_counts())

"""After defined a function, Let's call it. and check what's the output of our created function"""

explore_object_type(loan_train, 'Gender')

"""Here's one little issue occurred, Suppose in your datasets there are lots of feature to defined like this above code

 Solution is, Do you remember we have variable with name of `loan_train_columns`, Right,  let's use it

 'Loan_ID', 'Gender', 'Married', 'Dependents', 'Education', 'Self_Employed', 'Property_Area', 'Loan_Status'
"""

for featureName in loan_train_columns:
    if loan_train[featureName].dtype == 'object':
        print('\n"' + str(featureName) + '\'s" Values with count are :')
        explore_object_type(loan_train, str(featureName))

"""Note: Your output maybe shorter or longer, It's totally depend upon your dataset's columns

We need to fill null values with mean and median using missingno package
"""

import missingno as msno

loan_train
loan_train.isna().sum()
# round((loan_train.isna().sum() / len(loan_train)) * 100, 2)

msno.bar(loan_train)

msno.matrix(loan_train )

"""As we can see here, there are too many columns missing with small amount of null values so we use mean amd mode to replace with NaN values."""

loan_train['Credit_History'].fillna(loan_train['Credit_History'].mode(), inplace=True) # Mode
loan_test['Credit_History'].fillna(loan_test['Credit_History'].mode(), inplace=True) # Mode


loan_train['LoanAmount'].fillna(loan_train['LoanAmount'].mean(), inplace=True) # Mean
loan_test['LoanAmount'].fillna(loan_test['LoanAmount'].mean(), inplace=True) # Mean

"""# convert Categorical variable with Numerical values.

Loan_Status feature boolean values, So we replace Y values with 1 and N values with 0 and same for other Boolean types of columns
"""

loan_train.Loan_Status = loan_train.Loan_Status.replace({"Y": 1, "N" : 0})
# loan_test.Loan_Status = loan_test.Loan_Status.replace({"Y": 1, "N" : 0})

loan_train.Gender = loan_train.Gender.replace({"Male": 1, "Female" : 0})
loan_test.Gender = loan_test.Gender.replace({"Male": 1, "Female" : 0})

loan_train.Married = loan_train.Married.replace({"Yes": 1, "No" : 0})
loan_test.Married = loan_test.Married.replace({"Yes": 1, "No" : 0})

loan_train.Self_Employed = loan_train.Self_Employed.replace({"Yes": 1, "No" : 0})
loan_test.Self_Employed = loan_test.Self_Employed.replace({"Yes": 1, "No" : 0})

loan_train['Gender'].fillna(loan_train['Gender'].mode()[0], inplace=True)
loan_test['Gender'].fillna(loan_test['Gender'].mode()[0], inplace=True)

loan_train['Dependents'].fillna(loan_train['Dependents'].mode()[0], inplace=True)
loan_test['Dependents'].fillna(loan_test['Dependents'].mode()[0], inplace=True)

loan_train['Married'].fillna(loan_train['Married'].mode()[0], inplace=True)
loan_test['Married'].fillna(loan_test['Married'].mode()[0], inplace=True)

loan_train['Credit_History'].fillna(loan_train['Credit_History'].mean(), inplace=True)
loan_test['Credit_History'].fillna(loan_test['Credit_History'].mean(), inplace=True)

"""Here, Property_Area, Dependents and Education has multiple values so now we can use LabelEncoder from sklearn package"""

from sklearn.preprocessing import LabelEncoder
feature_col = ['Property_Area','Education', 'Dependents']
le = LabelEncoder()
for col in feature_col:
    loan_train[col] = le.fit_transform(loan_train[col])
    loan_test[col] = le.fit_transform(loan_test[col])

"""Finally, We have all the features with numerical values,


#3. Data Visualizations

In this section, We are showing the visual information from the dataset, For that we need some pakages that are matplotlib and seaborn
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline


import seaborn as sns
sns.set_style('dark')

loan_train

loan_train.plot(figsize=(18, 8))

plt.show()

#line plot with multiple variables plotted together

plt.figure(figsize=(18, 6))
plt.subplot(1, 2, 1)


loan_train['ApplicantIncome'].hist(bins=10)
plt.title("Loan Application Amount ")

plt.subplot(1, 2, 2)
plt.grid()
plt.hist(np.log(loan_train['LoanAmount']))
plt.title("Log Loan Application Amount ")

plt.show()

plt.figure(figsize=(18, 6))
plt.title("Relation Between Applicatoin Income vs Loan Amount ")

plt.grid()
plt.scatter(loan_train['ApplicantIncome'] , loan_train['LoanAmount'], c='k', marker='x')
plt.xlabel("Applicant Income")
plt.ylabel("Loan Amount")
plt.show()

plt.figure(figsize=(12, 6))
plt.plot(loan_train['Loan_Status'], loan_train['LoanAmount'])
plt.title("Loan Application Amount ")
plt.show()
#parallel coordinates plot-used to visualize multivariate numerical data

plt.figure(figsize=(12,8))
# Calculate correlation only for numerical features
numeric_features = loan_train.select_dtypes(include=np.number)  # Select only numerical columns
sns.heatmap(numeric_features.corr(), cmap='coolwarm', annot=True, fmt='.1f', linewidths=.1)
plt.show()

"""
#4. Choose ML Model.

In this step, We have a lots of Machine Learning Model from sklearn package, and we need to decide which model is give us the better performance. then we use that model in final stage and send to the production level"""

# import ml model from sklearn pacakge

from sklearn.linear_model import LogisticRegression

from sklearn.metrics import accuracy_score

"""First of all, we are use LogisticRegression from sklearn.linear_model package. Here is the little information about LogisticRegression.

Logistic Regression is a classification algorithm. It is used to predict a binary outcome (1 / 0, Yes / No, and True / False) given a set of independent variables. To represent binary / categorical outcome, we use dummy variables. You can also think of logistic regression as a special case of linear regression when the outcome variable is categorical, where we are using log of odds as the dependent variable.

![image.png](data:image/png;base64,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)

Let's build the model
"""

logistic_model = LogisticRegression()

"""Before fitting the model, We need to decide how many feature are available for testing and training, then after complete this step. fitt the model

Currently, we are using Credit_History', 'Education', 'Gender features for training so let's create train and test variables
"""

train_features = ['Credit_History', 'Education', 'Gender']

x_train = loan_train[train_features].values
y_train = loan_train['Loan_Status'].values

x_test = loan_test[train_features].values

logistic_model.fit(x_train, y_train)

"""
#6. Predict Model"""

predicted = logistic_model.predict(x_test)

print('Coefficient of model :', logistic_model.coef_)

print('Intercept of model',logistic_model.intercept_)

score = logistic_model.score(x_train, y_train)
print('accuracy_score overall :', score)
print('accuracy_score percent :', round(score*100,2))

predict_test = logistic_model.predict(x_test)
print('Target on test data',predict_test)

"""#7. Deploy Model

Finally, we are done so far. The last step is to deploy our model in production map. So we need to export our model and bind with web application API.
Using pickle we can export our model and store in to logistic_model.pkl file, so we can ealy access this file and calculate customize prediction using Web App API.

A little bit information about pickle:
Pickle is the standard way of serializing objects in Python. You can use the pickle operation to serialize your machine learning algorithms and save the serialized format to a file. Later you can load this file to deserialize your model and use it to make new predictions

Here is example of the Pickle export model

#model.fit(X_train, Y_train)
# save the model to disk
filename = 'finalized_model.sav'
pickle.dump(model, open(filename, 'wb'))

# some time later...

 #load the model from disk
loaded_model = pickle.load(open(filename, 'rb'))
result = loaded_model.score(X_test, Y_test)
print(result)
"""

import pickle as pkl

filename = 'logistic_model.pkl'
pkl.dump(logistic_model, open(filename, 'wb')) # wb means write as binary

"""Now, You can check your current directory. You can see the file with named "logistic_model.pkl"

To read model from file
"""

loaded_model = pkl.load(open(filename, 'rb'))
# Assuming 'train_features' contains the list of features used during training:
X_test = loan_test[train_features].values
# Predict on X_test using the loaded model
predicted_loan_status = loaded_model.predict(X_test)
# If you need Y_test for further analysis or evaluation:
Y_test = predicted_loan_status # This should only be done if you intend to use Y_test for an analysis where true values are not necessary. This is likely the case for your original code as it only used loaded_model.score(X_test, Y_test)

# load the model from disk
loaded_model = pkl.load(open(filename, 'rb')) # rb means read as binary
result = loaded_model.score(X_test, Y_test)

import pickle
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler # Import StandardScaler

# Assuming 'loan_train' contains your dataset and 'train_features' specifies features for training:
X = loan_train[train_features].values
y = loan_train['Loan_Status'].values

# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Adjust test_size and random_state as needed

# Now you have X_train and y_train for training the model
svc = SVC()
svc.fit(X_train, y_train)

pickle.dump(svc, open('diabetes.sav', 'wb'))

# Define and fit the scaler
scaler = StandardScaler() # Create a StandardScaler object
scaler.fit(X_train) # Fit the scaler to your training data

# Now you can save the scaler
pickle.dump(scaler, open('scalar.pkl', 'wb'))